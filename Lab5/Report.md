# Отчёт по лабораторной работе №5 (Вариант 24, Задания 6, 7)

## Задание 6

### Описание задания:

```
Реализуйте очередь с приоритетами. Ваша очередь должна поддерживать сле-
дующие операции: добавить элемент, извлечь минимальный элемент, уменьшить
элемент, добавленный во время одной из операций.

• Формат входного файла (input.txt). В первой строке входного файла со-
держится число n (1 ≤ n ≤ 106) - число операций с очередью.

Следующие n строк содержат описание операций с очередью, по одному
описанию в строке. Операции могут быть следующими:

– A x – требуется добавить элемент x в очередь.

– X – требуется удалить из очереди минимальный элемент и вывести
его в выходной файл. Если очередь пуста, в выходной файл требуется
вывести звездочку «*».

– D x y – требуется заменить значение элемента, добавленного в очередь
операцией A в строке входного файла номер x + 1, на y. Гарантиру-
ется, что в строке x + 1 действительно находится операция A, что
этот элемент не был ранее удален операцией X, и что y меньше, чем
предыдущее значение этого элемента.
В очередь помещаются и извлекаются только целые числа, не превышающие
по модулю 109.
```

### Код для решения задачи:

<img width="570" height="1500" alt="Lab5 HS6 Code" src="https://github.com/user-attachments/assets/d0ee1911-0e39-4083-b3dc-d29e90454daa" />

### Пояснение к коду:

Основа работы очереди с приоритетом - минимальная двоичная куча (та, которая
в корне хранит минимальный элемент), поэтому асимптотика у этого алгоритма,
как и у двоичной кучи, порядка O(log n).

Как это реализовано:
Я создал 3 массива:
- HeapValue - главный массив, хранящий элементы очереди
- HeapId - для хранения номеров операция
- pos - массив позиций

Каждый элемент, который добавляется с помощью операции А, получает
идентификатор, который равен номеру операции A, добавившей его, во
входном файле. (Номера операция мы храним исключительно для реализации
операции по уменьшению выбранного элемента) 

Теперь превратим обычный массив в кучу. Для этого напишем 3 функции:

Операция swap менят 2 элемента местами. Самая простая из операций, которая
просто меняет местами элементы в основной куче, идентификаторы в куче для
идентификаторов (так как даже если поменять элементы местами, порядок в котром 
они добавлялись нужно поддерживать) и обновляет позиции элементов в массиве позиций.

Операция SiftUp нужна для добавления нового элемента в кучу на правильную 
позицию. Она сравнивает значение элемента с значением его родителя и если
значение текущего элемента оказывается меньше, то меняет его местами с родителем,
при помощи функции swap, написанной ранее. 
И так пока элемент не займёт своё место в куче. Эта операция нужна для того, 
чтобы соблюдать структуру минимальной кучи после каждой операции.

И обратная операция SiftDown нужна для восстановления структуры кучи после
удаления из неё минимального элемента (обратная операция к SiftUp). Она сравнивает
знчение текущего элемента со значениями его потомков в поиске минимального из них.
Если потомок оказывается меньше родителя, то вызываем функцию swap и меняем их местами.
И так продолжается пока минимальная куча не будет восстановлена (до правильной 
минимальной кучи)

После написания операция для превращения массива в кучу, нужно написать операции
уже для преоритетной очереди:

Извлечение минимального элемента кучи (операция X). Самая простая
операция для работы с кучей, так как минимальный элемент в минимальной
двоичной куче всегда лежит в её корне (поэтому вообще для этого задания я
выбрал структуру минимальной кучи). То есть, алгоритм сначала проверяет
наличие элементов в куче вообще, если она пуста, то просто возвращает "*".
Если куча не пуста, то извлекается элемент из её корня. Сам корень заменятся 
последним элементом, размер кучи уменьшается на 1 и вызывается функция 
SiftDown для восстановления структуры.

Уменьшение значения элемента (операция D). С помощью массива позиций по
идентификатору элемента x мы берём его позицию. Заменяем значение элемента x
на значение элемента x-y. И вызываем функцию SiftUp для восстановления 
структуры кучи и правильного размещения обновлённого элемента.

А принцип работы последней операции добавления элемента (операции A)
уже описан выше, за исключением того, что после добавления значения 
элемента, мы тоже запускам функцию SiftUp для восстановления структуры
кучи.

В итоге у нас есть преорететная очередь, которая выполняет любую
операция за O(log n).

### Тесты:

Для проверки работоспособности алгоритма, я записал во входной файл
пример из описания задания в лабораторной и получил ожидаемый набор 
в вызодном файле. Прикрепляю скрины входного и выходной файлов.

<img width="400" height="400" alt="Lab5 HS6 Input" src="https://github.com/user-attachments/assets/b008fa22-8b46-41ff-a2d4-3129557c0732" /> <img width="400" height="400" alt="Lab5 HS6 Output" src="https://github.com/user-attachments/assets/b49da145-dd7b-49f8-a43f-a7370ca8a669" />



# Отчёт по лабораторной работе №5 (Вариант 24, Задания 6, 7)

## Задание 6

### Описание задания:

```
Реализуйте очередь с приоритетами. Ваша очередь должна поддерживать сле-
дующие операции: добавить элемент, извлечь минимальный элемент, уменьшить
элемент, добавленный во время одной из операций.

• Формат входного файла (input.txt). В первой строке входного файла со-
держится число n (1 ≤ n ≤ 106) - число операций с очередью.

Следующие n строк содержат описание операций с очередью, по одному
описанию в строке. Операции могут быть следующими:

– A x – требуется добавить элемент x в очередь.

– X – требуется удалить из очереди минимальный элемент и вывести
его в выходной файл. Если очередь пуста, в выходной файл требуется
вывести звездочку «*».

– D x y – требуется заменить значение элемента, добавленного в очередь
операцией A в строке входного файла номер x + 1, на y. Гарантиру-
ется, что в строке x + 1 действительно находится операция A, что
этот элемент не был ранее удален операцией X, и что y меньше, чем
предыдущее значение этого элемента.
В очередь помещаются и извлекаются только целые числа, не превышающие
по модулю 109.
```

### Код для решения задачи:

<img width="570" height="1500" alt="Lab5 HS6 Code" src="https://github.com/user-attachments/assets/d0ee1911-0e39-4083-b3dc-d29e90454daa" />

### Пояснение к коду:

Основа работы очереди с приоритетом - минимальная двоичная куча (та, которая
в корне хранит минимальный элемент), поэтому асимптотика у этого алгоритма,
как и у двоичной кучи, порядка O(log n).

Как это реализовано:
Я создал 3 массива:
- HeapValue - главный массив, хранящий элементы очереди
- HeapId - для хранения номеров операция
- pos - массив позиций

Каждый элемент, который добавляется с помощью операции А, получает
идентификатор, который равен номеру операции A, добавившей его, во
входном файле. (Номера операция мы храним исключительно для реализации
операции по уменьшению выбранного элемента) 

Теперь превратим обычный массив в кучу. Для этого напишем 3 функции:

Операция swap менят 2 элемента местами. Самая простая из операций, которая
просто меняет местами элементы в основной куче, идентификаторы в куче для
идентификаторов (так как даже если поменять элементы местами, порядок в котром 
они добавлялись нужно поддерживать) и обновляет позиции элементов в массиве позиций.

Операция SiftUp нужна для добавления нового элемента в кучу на правильную 
позицию. Она сравнивает значение элемента с значением его родителя и если
значение текущего элемента оказывается меньше, то меняет его местами с родителем,
при помощи функции swap, написанной ранее. 
И так пока элемент не займёт своё место в куче. Эта операция нужна для того, 
чтобы соблюдать структуру минимальной кучи после каждой операции.

И обратная операция SiftDown нужна для восстановления структуры кучи после
удаления из неё минимального элемента (обратная операция к SiftUp). Она сравнивает
знчение текущего элемента со значениями его потомков в поиске минимального из них.
Если потомок оказывается меньше родителя, то вызываем функцию swap и меняем их местами.
И так продолжается пока минимальная куча не будет восстановлена (до правильной 
минимальной кучи)

После написания операция для превращения массива в кучу, нужно написать операции
уже для преоритетной очереди:

Извлечение минимального элемента кучи (операция X). Самая простая
операция для работы с кучей, так как минимальный элемент в минимальной
двоичной куче всегда лежит в её корне (поэтому вообще для этого задания я
выбрал структуру минимальной кучи). То есть, алгоритм сначала проверяет
наличие элементов в куче вообще, если она пуста, то просто возвращает "*".
Если куча не пуста, то извлекается элемент из её корня. Сам корень заменятся 
последним элементом, размер кучи уменьшается на 1 и вызывается функция 
SiftDown для восстановления структуры.

Уменьшение значения элемента (операция D). С помощью массива позиций по
идентификатору элемента x мы берём его позицию. Заменяем значение элемента x
на значение элемента x-y. И вызываем функцию SiftUp для восстановления 
структуры кучи и правильного размещения обновлённого элемента.

А принцип работы последней операции добавления элемента (операции A)
уже описан выше, за исключением того, что после добавления значения 
элемента, мы тоже запускам функцию SiftUp для восстановления структуры
кучи.

В итоге у нас есть преорететная очередь, которая выполняет любую
операция за O(log n).

### Тесты:

Для проверки работоспособности алгоритма, я записал во входной файл
пример из описания задания в лабораторной и получил ожидаемый набор 
в вызодном файле. Прикрепляю скрины входного и выходной файлов.

<img width="400" height="400" alt="Lab5 HS6 Input" src="https://github.com/user-attachments/assets/b008fa22-8b46-41ff-a2d4-3129557c0732" /> <img width="400" height="400" alt="Lab5 HS6 Output" src="https://github.com/user-attachments/assets/b49da145-dd7b-49f8-a43f-a7370ca8a669" />

## Задание 7:

### Описание задания:

```
Напишите программу пирамидальной сортировки на Python для последова-
тельности в убывающем порядке. Проверьте ее, создав несколько рандомных
массивов, подходящих под параметры:

• Формат входного файла (input.txt). В первой строке входного файла со-
держится число n (1 ≤ n ≤ 105) — число элементов в массиве. Во второй
строке находятся n различных целых чисел, по модулю не превосходящих
109.

• Формат выходного файла (output.txt). Одна строка выходного файла с от-
сортированным по невозрастанию массивом. Между любыми двумя числами
должен стоять ровно один пробел.

• Для проверки можно выбрать случай, когда сортируется массив размера
103, 104, 105 чисел порядка 109, отсортированных в обратном порядке; ко-
гда массив уже отсортирован в нужном порядке; когда много одинаковых
элементов, всего 4-5 уникальных; средний - случайный. Сравните на данных
сетах Randomized-QuickSort, MergeSort, HeapSort, InsertionSort.

• Есть ли случай, когда сортировка пирамидой выполнится за O(n)?

* Напишите процедуру Max-Heapify, в которой вместо рекурсивного вызова
использовалась бы итеративная конструкция (цикл).
```

### Код решения :

<img width="577" height="902" alt="Lab5 HS7 Code" src="https://github.com/user-attachments/assets/1d4d502d-352f-4c8a-95a3-45aa2e294c68" />

### Пояснение:

Код на скриншоте уже удовлетворяет условию со звёздочкой, так как
он не вызывает функцию рекурсивно, а использует вместо этого цикл.
Основная функция в коде - PyramidSort, она выполняет пирамидальную 
сортировку и сразу возвращает время, за которое справилась с массивом.
В начале я создал массив a и сделал его чуть больше необходимого, чтобы
использовать индексацию с 1. Внутри главной функции есть вспомогательная - 
Heapify, которая восстанавливает структуру максимальной кучи (а именно на ней
и построена пирамидальная сортировка), она работает по тем же принципам, что
и SiftUp и SiftDown, то есть сравнивает текущий элемент с потомкаим, просто
ищет не минимальное значение для них, а максимамльное. Heapify - это принятое
название как раз для функции, восстанавливающей структуру максимальной кучи.
Сама пирмаида строится за O(n), просто вызывая Heapify для всех вершин кучи.
Сортировка работает следующим образом. Максимальный элемент постепеноо меняется
с последним элементом массива, после размер кучи уменьшается и вызывается Heapify.
Но в итоге мы получаем массив отсортированный по возрастанию и для получения 
отсортированного по цбыванию массива, мы его разворачиваем.

Далее в том же файле я написал код, генерирующий 4 массива 
(в каждом по 10_000 элементов, порядка 10**9) и записывающий их
во входной файл. Эти 4 массива - отсортированный по убыванию, отсортированный
по возрастанию, тот, где много одинаковых элементов и мало уникальных, и 
рандомный массив. Я запустил код и получил следующее время работы алгоритма с
разными типами массивов. Прикрепляю скриншот.


<img width="549" height="392" alt="Lab5 HS7 Output" src="https://github.com/user-attachments/assets/46397a5c-1ed1-4f59-94f3-8c40802adc1d" />

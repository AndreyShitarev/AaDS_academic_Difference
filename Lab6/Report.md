# Отчёт по лабораторной работе №6 (Вариант 24)

Сначала посчитаем кномер обязательной задачи по функции
H(v) = (A · v mod p) mod 9. Номер моего варианта 24, 
номер группы K3240, знаит последние 2 цифры это 4 и 0.
Моя фамилия - Шитарев, сумма кодов её букв равна 7541. 
Подставляем значения в формулу и получаем, что обяхательное задание -
задание 6 (960 mod 9).
Выбрем ещё 2 задания с учётом того, что все номера выюранных
заданий не могут стоять подряд. Пусть это будут задания 1 и 2.

Итого мои задания - 1, 2, 6.

## Задание 1:

### Описание задания:

```
Реализуйте множество с операциями «добавление ключа», «удаление ключа»,
«проверка существования ключа».

• Формат входного файла (input.txt). В первой строке входного файла на-
ходится строго положительное целое число операций N, не превышающее
5 · 10^5

. В каждой из последующих N строк находится одна из следующих
операций:

– A x – добавить элемент x в множество. Если элемент уже есть в мно-
жестве, то ничего делать не надо.

– D x – удалить элемент x. Если элемента x нет, то ничего делать не
надо.
– ? x – если ключ x есть в множестве, выведите «Y», если нет, то выведите
«N».

Аргументы указанных выше операций – целые числа, не превышающие по
модулю 10^18.

• Формат выходного файла (output.txt). Выведите последовательно резуль-
тат выполнения всех операций «?». Следуйте формату выходного файла из
примера.

• Ограничение по времени. 2 сек.
• Ограничение по памяти. 256 мб.

• Примечание.
Эту задачу можно решить совершенно разными способами, включая исполь-
зование различных средств стандартных библиотек (правда, не всех - в стан-
дартных библиотеках некоторых языков программирования используются
слишком предсказуемые методы хеширования). Именно по этой причине ее
разумно использовать для проверки реализаций хеш-таблиц, которые пона-
добятся в следующих задачах этой работы.
```


## Код для решения:

<img width="660" height="914" alt="Lab6 HF1 Code" src="https://github.com/user-attachments/assets/e82a5629-ad0b-4ef3-97ec-98465814dc9c" />

### Пояснение решения:

Вводим переменную Size, в которой задаём размер будущей хэш таблицы, 
берём с запасом, по идее это должно уменьшить количество коллизий. Далее
создаём список table, который и будем делать хэш таблицей. Далее создаём таблицу
с помощью цикла, по сути получаем список из пустых списков. + создаём вспомогательный
список res, в котром будем хрнаить ответы на запросы "?". Обрабатываем входной файл и
отделяем тип команды от её значения. 

Теперь сам алгоритм. Вычисляем хэш каждого значения команды по формуле abs(x) % Size.
Мы находим остаток от деления модуля значения на размер таблицы и получаем индекс ячейки
в таблице, в котром он будет храниться. Далее из таблицы мы берём список, который соответствует
вычисленному хэшу и записываем его в переменную HashInTable. 

Операция A, то есть команда на добавление элемента. Перебираем все элементы списка,
если элемент уже есть в списке, то помечаем это флагом found = True, который в начале
задали как False. Переходим к следующему элементу списка. Если же элемента в списке
не нашлось, то просто добавляем его. 

Операция D, то есть операция удаления. Снова перебираем все элементы множества
циклом. Если находим нужный элемент, то удаляем его и завершаем цикл. Если элемента
в списке нет, то цикл просто пройдёт по всеми элементам и ничго не сделает.

Операция ?, то есть команда, которая проверяет существует ли элемент в списке.
Снова вводим флаг наличия элемента, как в реализации операции доавления.
Перебираем все элементы соответстввующего списка с помощью цикла. Если находим
нужный элемент, то меняем флаг на True и выходим из цикла. Если флаг помечен как
Treue, то добавляем Y в список ответов, если не помечен, то добавляем N.

Если же можно использовать средства стандартных библиотек, то можно было просто
импортировать структуру множества и сильно уменьшить код, но я тогда не понял в 
чём был бы смысл задания.

## Тест:

Для тест я записал во входной файл данные из примера в описании лабы и получил
совпадающий с результатом, описанным в задании, результат. Прикрепляю скрины 
входного и выходного файлов.

<img width="400" height="400" alt="Lab6 HF1 Input" src="https://github.com/user-attachments/assets/ec0ab3da-824e-487e-8652-8aff0d815089" /> <img width="400" height="400" alt="Lab6 HF1 Output" src="https://github.com/user-attachments/assets/a5c4b97b-8d26-45aa-a87e-a706751623a3" />



## Задание 2:

### Описание задания:

```
В этой задаче ваша цель - реализовать простой менеджер телефонной книги.
Он должен уметь обрабатывать следующие типы пользовательских запросов:
• add number name – это команда означает, что пользователь добавляет в
телефонную книгу человека с именем name и номером телефона number.
Если пользователь с таким номером уже существует, то ваш менеджер дол-
жен перезаписать соответствующее имя.

• del number – означает, что менеджер должен удалить человека с номе-
ром из телефонной книги. Если такого человека нет, то он должен просто
игнорировать запрос.

• find number – означает, что пользователь ищет человека с номером те-
лефона number. Менеджер должен ответить соответствующим именем или
строкой «not found» (без кавычек), если такого человека в книге нет.

• Формат ввода / входного файла (input.txt). В первой строке входного
файла содержится число N (1 ≤ N ≤ 105) - количество запросов. Далее
следуют N строк, каждая из которых содержит один запрос в формате,
описанном выше.

Все номера телефонов состоят из десятичных цифр, в них нет нулей в начале
номера, и каждый состоит не более чем из 7 цифр. Все имена представляют
собой непустые строки из латинских букв, каждая из которых имеет длину
не более 15. Гарантируется при проверке, что не будет человека с именем
«not found».

• Формат вывода / выходного файла (output.txt). Выведите результат каж-
дого поискового запроса find – имя, соответствующее номеру телефона,
или «not found» (без кавычек), если в телефонной книге нет человека с та-
ким номером телефона. Выведите по одному результату в каждой строке в
том же порядке, как были заданы запросы типа find во входных данных.

• Ограничение по времени. 6 сек.
• Ограничение по памяти. 512 мб.
```

## Код для решения задания:

<img width="765" height="530" alt="Lab6 HF2 Code" src="https://github.com/user-attachments/assets/aef7c0c7-2837-4b3e-a9bc-c9d5d0ffcef1" />

### Пояснение кода:

Телефонная книга организована на основе словаря, который хранит имена и номера телефонов,
и списка для записи результатов. 
Обрабатываем входной файл, отделяем тип команды и реализуем их.

- add - делим аргумент, идущий после типа команды, на 2 части, то есть на имя и номер.
  Добавляем в словарь новую пару имя-номер.

- del - выделяем аргумент, отвечающий за значение, которое надо удалить. Проверяем,
  есть ли такой номер в телфефонной книге, если есть - удаляем. Если нет - ничего не делаем.

- find - Выделяем часть сстроки, в котрой записано значение, которое надо найти. Проверяем,
  есть ли такой номер в телефонной книге. Если есть - добавляем имя, соответствующее найденному
  номеру в список res.

## Тесты:

В качестве тестов взял 2 примера из описания задания в лабе. Записал входные данные из примера
во входной файл и получил совпадающий с примером результат в выходном файле. Прикрепляю скрины
входной и выходного файлов.

## Тест 1

<img width="400" height="400" alt="Lab6 HF2 Input1" src="https://github.com/user-attachments/assets/20ba1e1e-1f03-46f9-8bb4-2408993b8d5a" /> <img width="400" height="400" alt="Lab6 HF2 Output1" src="https://github.com/user-attachments/assets/cfdbff79-c171-46af-b060-9bf37ede1961" />

## Тест 2

<img width="400" height="400" alt="Lab6 HF2 Input2" src="https://github.com/user-attachments/assets/6c3ce93b-8a02-489e-a4f5-4c599feea1e0" /> <img width="400" height="400" alt="Lab6 HF2 Output2" src="https://github.com/user-attachments/assets/92b290f2-2747-4be6-8f5c-abc7c689d221" />



## Задание 6

### Описание задания:

```
Вам дается последовательность чисел. Для каждого числа определите, явля-
ется ли оно числом Фибоначчи. Напомним, что числа Фибоначчи определяются,
например, так:

F0 = F1 = 1 (1)
Fi = Fi−1 + Fi−2 для i ≥ 2.

• Формат ввода / входного файла (input.txt). Первая строка содержит од-
но число N (1 ≤ N ≤ 106) - количество запросов. Следующие N строк
содержат по одному целому числу. При этом соблюдаются следующие огра-
ничения при проверке:

1. Размер каждого числа не превосходит 5000 цифр в десятичном пред-
ставлении.

2. Размер входа не превышает 1 Мб.

• Формат вывода / выходного файла (output.txt). Для каждого числа, дан-
ного во входном файле, выведите «Yes», если оно является числом Фибо-
наччи, и «No» в противном случае.

• Ограничение по времени. 2 сек.
• Ограничение по памяти. 128 мб.Внимание: есть вероятность превышения
по памяти, т.к. сами по себе числа Фибоначчи большие. Делайте проверку
на память!
```

## Код решения

<img width="653" height="482" alt="Lab6 HF6 Code" src="https://github.com/user-attachments/assets/79a40ee3-f880-4eaa-b905-db8055066c51" />

### Пояснение кода:

Основная идея алгоритма заключается в свойстве чисел Фиббоначи. А именно
n - число Фиббоначи, если 5*n^2 + 4 или 5*n^2 -4 являются точным квадратом числа.
Поэтому код просто обрабатывает входной файл, записывает число Фиббоначи в переменную a,
вычисляет квадрат a и проверяет является результат формул из критерия точным квадратом
какого-то числа, для этого в начале кода импортирована библотека math, эта функция ищет
целую часть квадратнго корня и если результат этой функции возвести в квадрат и сравнить
с изнаальным число, то мы получим True - если это точный квадрат, иначе False.

## Тест:

В качестве теста вписал во входной файл пример из описания задания и в выходном 
файле получил совпадающий с результатом из пример результат. Прикрепляю скрины
входной и выходного файлов.

<img width="400" height="400" alt="Lab6 HF6 Input" src="https://github.com/user-attachments/assets/9575b626-5937-4fe9-857a-e4cd5947d2c9" /> <img width="400" height="400" alt="Lab6 HF6 Output" src="https://github.com/user-attachments/assets/c137d22a-f49f-45ca-8385-6fa7831d791f" />


# Отчёт по лабораторной работе №3 (Вариант 24, Задания 1, 3, 7)

## Задание 1

### Текст задания:

```
1. Используя псевдокод процедуры Randomized - QuickSort, а так же Partition
из презентации к Лекции 3 (страницы 8 и 12), напишите программу быстрой
сортировки на Python и проверьте ее, создав несколько рандомных массивов,
подходящих под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 104

) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109
.

• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2 сек.
• Ограничение по памяти. 256 мб.
• Для проверки можно выбрать наихудший случай, когда сортируется
массив рамера 103
, 104
, 105 чисел порядка 109

, отсортированных в об-
ратном порядке; наилучший, когда массив уже отсортирван, и средний

- случайный. Сравните на данных сетах Randomized-QuickSort и про-
стой QuickSort. (А также есть Median-QuickSort, см. задание 10.2;

и Tail-Recursive-QuickSort, см. Кормен. 2013, стр. 217)

2. Основное задание. Цель задачи - переделать данную реализацию рандо-
мизированного алгоритма быстрой сортировки, чтобы она работала быстро

даже с последовательностями, содержащими много одинаковых элементов.
Чтобы заставить алгоритм быстрой сортировки эффективно обрабатывать

последовательности с несколькими уникальными элементами, нужно заме-
нить двухстороннее разделение на трехстороннее (смотри в Лекции 3 слайд

17). То есть ваша новая процедура разделения должна разбить массив на три
части:
• A[k] < x для всех l + 1 ≤ k ≤ m1 − 1
• A[k] = x для всех m1 ≤ k ≤ m2
• A[k] > x для всех m2 + 1 ≤ k ≤ r
• Формат входного и выходного файла аналогичен п.1.
• Аналогично п.1 этого задания сравните Randomized-QuickSort +c
Partition и ее с Partition3 на сетах случайных данных, в которых
содержатся всего несколько уникальных элементов при n = 103
, 104
, 105
.
Что быстрее, Randomized-QuickSort +c Partition3 или Merge-Sort?
```

### Код решения:

<img width="899" height="1138" alt="Lab3 QS1 main code" src="https://github.com/user-attachments/assets/f77161ac-53d8-4e76-a69d-dd8908864835" />

### Пояснение к коду:

Я написал 4 быстрые сортировки

- RandomizedQuickSort - сортировка, которая выбирает случайный элемент в качестве опорного
- SimpleQuickSort - сортировка, которая выбирает опорным элементом последний элемент массива
- MedianQuickSort - сортировка, которая выбирает опорный элемент как медиану из трёх
- TailRecursiveQuickSort - сортировка, которая отправляет большую часть массива после разделения в цикл while

Сейчас я бы не заострял внимания на реализации каждой из сортировок (они написаны переводом псевдокода в Python код
и не имеют каких-то интересных собственных решений), а обратил его на результаты тестирования времени работы

### Тесты

Я решил написать тесты к этим сортировкам внутри этого же файла, прикрепляю скрин первой версии реализации

<img width="858" height="1026" alt="Lab3 QS1 Tests version1" src="https://github.com/user-attachments/assets/4e0fc630-56ed-4ead-8fe1-6807f70277b4" />

Тут я создаю 6 различных видов массивов

1. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
   при этом отсортированный в обратном порядке - назовём его - худший случай
   
2. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
   состоящий из рандомных элементов - назовём его - средний случай
   
3. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
    при этом полностью отсортированный - назовём его - лучший случай
   
4. Массив с количеством элементов порядка 10**3 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный1
   
5. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный2
   
6. Массив с количеством элементов порядка 10**5 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный3

Я заустил код и столкнуся с первой проблемой, прождав 10 минут в файл output.txt так и не
был записан результат. Значит какая-то сортиовка с каким-то массивом справлялась крайне плохо,
но я не знал какая и с каким, поэтом я решил подредактировать код проверки и получил следующее:

<img width="882" height="1036" alt="Lab3 QS1 Tests version2" src="https://github.com/user-attachments/assets/f7230098-bf63-4ece-a3a0-2957cadde2ee" />

В этой версии как только сортировка отработала массив, она писала результат в консоль и я
мог понять на каком моменте начинается очень длинная задержка. Я запустил новый код и снова
отошёл на 10 минут. Вернувшись, я увидел следующее:

<img width="308" height="132" alt="Lab3 QS1 output for version2" src="https://github.com/user-attachments/assets/a5811279-0eff-4566-95da-0131adc87026" />

Стало понятно, что для рандомной быстрой сортировки массив из 100_000 элементов порядка 10**9 непосилен за короткое время,
так как я ожидал, что этот вариант быстрой сортироовки будет одним из самых эффективных, я предположил, что
другие быстрые сортировки будут работать ещё медленне и чтобы всё-таки увидеть результат всех сортировок, решил
просто убать массив Unique3, где порядок элментов 10**5. Убрал, запустил и наконец получил полный результат:

<img width="574" height="561" alt="Lab3 QS1 outptut last" src="https://github.com/user-attachments/assets/e3309d4d-65e1-4eae-9c79-49f9bb52baa4" />

Честно говоря, результат не самый ожидаемый. 

Во-первых оказалось, что рандомная и медианная сортировки - самые эффективные для всех типов массивов

Во-вторых оказалось, что все сортировки хоошо справляются с массивами, состоящими практически из одинаковых элементов

В-третьих оказалось, что с лучшим вариантом массива, полностью отсортированным, каждая из быстрых сортировок справилась хуже,
чем с худшим вариантом массива, полностью перевёрнутым в обратную сторону.

Основной вывод - рандомная и медианая быстрые сортировки самые эффективные для любого типа массивов




    





# Отчёт по лабораторной работе №3 (Вариант 24, Задания 1, 3, 7)

## Задание 1

### Текст задания:

```
1. Используя псевдокод процедуры Randomized - QuickSort, а так же Partition
из презентации к Лекции 3 (страницы 8 и 12), напишите программу быстрой
сортировки на Python и проверьте ее, создав несколько рандомных массивов,
подходящих под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 104

) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109
.

• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2 сек.
• Ограничение по памяти. 256 мб.
• Для проверки можно выбрать наихудший случай, когда сортируется
массив рамера 103
, 104
, 105 чисел порядка 109

, отсортированных в об-
ратном порядке; наилучший, когда массив уже отсортирван, и средний

- случайный. Сравните на данных сетах Randomized-QuickSort и про-
стой QuickSort. (А также есть Median-QuickSort, см. задание 10.2;

и Tail-Recursive-QuickSort, см. Кормен. 2013, стр. 217)

2. Основное задание. Цель задачи - переделать данную реализацию рандо-
мизированного алгоритма быстрой сортировки, чтобы она работала быстро

даже с последовательностями, содержащими много одинаковых элементов.
Чтобы заставить алгоритм быстрой сортировки эффективно обрабатывать

последовательности с несколькими уникальными элементами, нужно заме-
нить двухстороннее разделение на трехстороннее (смотри в Лекции 3 слайд

17). То есть ваша новая процедура разделения должна разбить массив на три
части:
• A[k] < x для всех l + 1 ≤ k ≤ m1 − 1
• A[k] = x для всех m1 ≤ k ≤ m2
• A[k] > x для всех m2 + 1 ≤ k ≤ r
• Формат входного и выходного файла аналогичен п.1.
• Аналогично п.1 этого задания сравните Randomized-QuickSort +c
Partition и ее с Partition3 на сетах случайных данных, в которых
содержатся всего несколько уникальных элементов при n = 103
, 104
, 105
.
Что быстрее, Randomized-QuickSort +c Partition3 или Merge-Sort?
```

### Код решения:

<img width="899" height="1138" alt="Lab3 QS1 main code" src="https://github.com/user-attachments/assets/f77161ac-53d8-4e76-a69d-dd8908864835" />

### Пояснение к коду:

Я написал 4 быстрые сортировки

- RandomizedQuickSort - сортировка, которая выбирает случайный элемент в качестве опорного
- SimpleQuickSort - сортировка, которая выбирает опорным элементом последний элемент массива
- MedianQuickSort - сортировка, которая выбирает опорный элемент как медиану из трёх
- TailRecursiveQuickSort - сортировка, которая отправляет большую часть массива после разделения в цикл while

Сейчас я бы не заострял внимания на реализации каждой из сортировок (они написаны переводом псевдокода в Python код
и не имеют каких-то интересных собственных решений), а обратил его на результаты тестирования времени работы

### Тесты

Я решил написать тесты к этим сортировкам внутри этого же файла, прикрепляю скрин первой версии реализации

<img width="858" height="1026" alt="Lab3 QS1 Tests version1" src="https://github.com/user-attachments/assets/4e0fc630-56ed-4ead-8fe1-6807f70277b4" />

Тут я создаю 6 различных видов массивов

1. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
   при этом отсортированный в обратном порядке - назовём его - худший случай
   
2. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
   состоящий из рандомных элементов - назовём его - средний случай
   
3. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
    при этом полностью отсортированный - назовём его - лучший случай
   
4. Массив с количеством элементов порядка 10**3 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный1
   
5. Массив с количеством элементов порядка 10**4 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный2
   
6. Массив с количеством элементов порядка 10**5 и каждым элементом порядка 10**9,
    при этом такой, в которым всего несколько уникальных элементов, а остальные одинаковые
    назовём его Уникальный3

Я заустил код и столкнуся с первой проблемой, прождав 10 минут в файл output.txt так и не
был записан результат. Значит какая-то сортиовка с каким-то массивом справлялась крайне плохо,
но я не знал какая и с каким, поэтом я решил подредактировать код проверки и получил следующее:

<img width="882" height="1036" alt="Lab3 QS1 Tests version2" src="https://github.com/user-attachments/assets/f7230098-bf63-4ece-a3a0-2957cadde2ee" />

В этой версии как только сортировка отработала массив, она писала результат в консоль и я
мог понять на каком моменте начинается очень длинная задержка. Я запустил новый код и снова
отошёл на 10 минут. Вернувшись, я увидел следующее:

<img width="308" height="132" alt="Lab3 QS1 output for version2" src="https://github.com/user-attachments/assets/a5811279-0eff-4566-95da-0131adc87026" />

Стало понятно, что для рандомной быстрой сортировки массив из 100_000 элементов порядка 10**9 непосилен за короткое время,
так как я ожидал, что этот вариант быстрой сортироовки будет одним из самых эффективных, я предположил, что
другие быстрые сортировки будут работать ещё медленне и чтобы всё-таки увидеть результат всех сортировок, решил
просто убать массив Unique3, где порядок элментов 10**5. Убрал, запустил и наконец получил полный результат:

<img width="574" height="561" alt="Lab3 QS1 outptut last" src="https://github.com/user-attachments/assets/e3309d4d-65e1-4eae-9c79-49f9bb52baa4" />

Честно говоря, результат не самый ожидаемый. 

Во-первых оказалось, что рандомная и медианная сортировки - самые эффективные для всех типов массивов

Во-вторых оказалось, что все сортировки хоошо справляются с массивами, состоящими практически из одинаковых элементов

В-третьих оказалось, что с лучшим вариантом массива, полностью отсортированным, каждая из быстрых сортировок справилась хуже,
чем с худшим вариантом массива, полностью перевёрнутым в обратную сторону.

Основной вывод - рандомная и медианая быстрые сортировки самые эффективные для любого типа массивов




## Задание 3

### Текст задания:

```
«Сортировка пугалом» — это давно забытая народная потешка. Участнику
под верхнюю одежду продевают деревянную палку, так что у него оказываются
растопырены руки, как у огородного пугала. Перед ним ставятся n матрёшек в
ряд. Из-за палки единственное, что он может сделать — это взять в руки две
матрешки на расстоянии k друг от друга (то есть i-ую и i + k-ую), развернуться и
поставить их обратно в ряд, таким образом поменяв их местами.
Задача участника — расположить матрёшки по неубыванию размера. Может
ли он это сделать?
• Формат входного файла (input.txt). В первой строчке содержатся числа
n и k (1 ≤ n, k ≤ 105

) – число матрёшек и размах рук. Во второй строчке
содержится n целых чисел, которые по модулю не превосходят 109 – размеры
матрёшек.
• Формат выходного файла (output.txt). Выведите «ДА», если возможно
отсортировать матрёшки по неубыванию размера, и «НЕТ» в противном
случае.
```

### Код решения:

<img width="669" height="366" alt="Lab3 QS3 Code" src="https://github.com/user-attachments/assets/d9dd90f1-55e4-4855-996c-65b32658516b" />

### Пояснение:

Сам код для решения это задачи очень прост, главное понять главную идею решения. Она такая.
Мы можем менять только элементы с индексами i и i+n. Это значит, что элемент не может попасть на позицию,
чей индекс при операции взятия остатка по модулю н будет другим. Мы можем разбить все позиции массива 
на n групп, между которыми элементы перемещаться не могут, движение может быть только внутри такой группы.
Итак, чтобы проверить можно ли отсортировать массив, мы построим остортированную версию массива. Далее будем брать
для каждой группы индексов с одинаковым остатком по модулю n элементы остортированного массива, и сравнивать их как
множества, без учёта повторения элементов внутри и если элементы в текущей группе совпадают, то это значит, что
отсортировать возможно, если не совпадают, то нельзя.

### Проверка:

Для проверки алгоритма я просто взял примеры из самой лабы и получил такой результат:

Пример 1

<img width="551" height="365" alt="Lab3 QS3 Input1" src="https://github.com/user-attachments/assets/1473b45f-e9d2-4da1-b15c-cf5df1bd71d0" />

<img width="551" height="367" alt="Lab3 QS3 Output1" src="https://github.com/user-attachments/assets/5ec47c8b-1f02-42ce-af79-97868f7b65c3" />


Пример 2

<img width="549" height="366" alt="Lab3 QS3 Input2" src="https://github.com/user-attachments/assets/2ee54c11-d951-4e7a-8e41-a173f9a366d7" />

<img width="550" height="360" alt="Lab3 QS3 Output2" src="https://github.com/user-attachments/assets/431246b4-3742-4dae-8824-86e009460537" />


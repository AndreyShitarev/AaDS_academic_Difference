# Отчёт по лабораторной работе №1 (24 вариант, задания 1, 6, 9)

## Задание №1

### Текст задания:
```
Используя код процедуры Insertion-sort, напишите программу и проверьте сор-
тировку массива A = {31, 41, 59, 26, 41, 58}.

• Формат входного файла (input.txt). В первой строке входного файла со-
держится число n (1 ≤ n ≤ 103

) — число элементов в массиве. Во второй
строке находятся n различных целых чисел, по модулю не превосходящих
109
.
• Формат выходного файла (output.txt). Одна строка выходного файла с
отсортированным массивом. Между любыми двумя числами должен стоять
ровно один пробел.
• Ограничение по времени. 2сек.
• Ограничение по памяти. 256 мб.
Выберите любой набор данных, подходящих по формату, и протестируйте
алгоритм.
```

### Скришот кода решения:

<img width="809" height="410" alt="Lab1 IS1" src="https://github.com/user-attachments/assets/d209214c-bd2f-4580-b287-1f6af78b7da8" />

### Пояснение:

Для решения этого задания я написал самый простой вариант сортировки вставками. 
Не использовал число n, которое находилось в первой строке входного файла, 
вместо этого высчитывал n как длину массива, полученного во второй строке, потому что
код так выглядит короче и понятее (если нужно, можно легко изменить, просто передавая в функция 
сортировки не только массив, но и количество элементов в нём.  Соблюдён формат выходного файла, 
то есть между любыми двумя числами стоит пробел. Так как задание заключалось просто в написании 
сортировки вставками проблем не возникло. Я написал эту сортировку по принципу перевода псевдокода
сортировки вставками в реальный код на Python.




## Задание №6

### Текст задания:
```
Пузырьковая сортировка представляет собой популярный, но не очень эф-
фективный алгоритм сортировки. В его основе лежит многократная перестановка
соседних элементов, нарушающих порядок сортировки.
Напишите код на Python и докажите корректность пузырьковой сортиров-
ки. Для доказательства корректоности процедуры вам необходимо доказать, что
она завершается и что A′
[1] ≤ A′
[2] ≤ ... ≤ A′
[n], где A′
- выход процедуры
Bubble_Sort, a n - длина массива A.
Определите время пузырьковой сортировки в наихудшем случае и в среднем
случае и сравните его со временем сортировки вставкой.
Формат входного и выходного файла и ограничения - как в задаче 1.
```

### Скришот кода решения:

<img width="768" height="288" alt="Lab1 IS6" src="https://github.com/user-attachments/assets/67abdce2-8a0e-49c1-8d22-33e981e6a85c" />


### Пояснение:

Код для решения этого задания я написал так же как и код для задания 1 по принципу
переписывания псевдокода в код Python. Блок чтения и записи файла полностью идентичен коду
из задания 1, так как формат входного файла и требования к выходноу тоже одинковые

### Доказательство работоспособности:

В качестве доказательства прикрепляю 2 скриншота
Скриншот 1 - содержимое входного файла
Скриншот 2 - содержимое выходного файла

Скриншот 1

<img width="831" height="614" alt="исходник6" src="https://github.com/user-attachments/assets/b6ee518d-da22-4744-961a-577766a804ac" />

Скришот 2

<img width="837" height="588" alt="результат6" src="https://github.com/user-attachments/assets/93451e5c-f613-4629-b20a-6ffded38dae7" />

### Оценка времени работы пузырьковой сортировки:

В худшем и среднем случае сортировка пузырьком работает за O(n^2), в лучшем за O(n),
Лучший случай для пузырьковой сортировки - уже частично отсортированные массивы.
По сути сортировка пузрьком имеет точно такую же асимптотику как и сортировка вставками, 
но на деле последняя более эффективна, так как она просто сдвиагет элементы в массиве, то есть
совершает одну операцию присваивания. А сортировка пузырьком меняет элементы местами, для чего
нужно уже 3 операции присваивания. 





## Задание №9

### Текст задания:
```
Расмотрим задачу сложения двух n-битовых двоичных целых чисел, храня-
щихся в n-элементных массивах A и B. Сумму этих двух чисел необходимо

занести в двоичной форме в (n + 1)-элементный массив C. Напишите скрипт для
сложения этих двух чисел.

• Формат входного файла (input.txt). В одной строке содержится два n-
битовых двоичных числа, записанные через пробел (1 ≤ n ≤ 103

)
• Формат выходного файла (output.txt). Одна строка - двоичное число,
которое является суммой двух чисел из входного файла.
• Оцените асимптотическое время выполнение вашего алгоритма.
```

### Скришот кода решения:

<img width="660" height="579" alt="Lab1 IS9" src="https://github.com/user-attachments/assets/75f77813-dc16-45ed-b6c7-870fc6e40fa0" />

### Пояснение:

Как работает этот алгоритм? Он принимает на вход 2 числа в двоичной форме записи из файла input.txt.
Затем он находит длину наибольшего из них и записывает в n. Затем он заполняет более короткое из чисел 
ведущими нулями до длины большего числа. И содаёт переменную c, для записи результата, при этом C состоит
из 0, в количестве на 1 больше, чем скадываемые числа. Также мы вводим переменную perenos, в которую будем 
записывать число, которое необходимо будет добавить при переносе в следуюший разряд. Далее скаладываеем самым
понятным способом, то есть от меньших разрядов к большим. Для этого идём циклом for из конца в начало. 
Каждый разяд итогового результата считается как этот разряд из числа A + этот разряд из числа B + перенос, 
если он для этого разряда есть (если нет, то perenos просто равно 0). После сложения мы разделяем результат на то, что
пойдет в итоговое число C и на то, что пойдёт в переменную perenos для сложения со следующим разрядом.
В самом конце, уже после завершения цикла, мы записываем оставшийся перенос в ведущий разряд ответа C, 
и наконец передаём этот результат. 

### Доказательство работоспособности:

В качестве доказательства прикрепляю 2 скриншота
Скриншот 1 - содержимое входного файла
Скриншот 2 - содержимое выходного файла

Скриншот 1

<img width="446" height="237" alt="Lab1 IS9 input" src="https://github.com/user-attachments/assets/aa23a9f2-84e6-4ebd-8584-8b0f39c7bf5e" />


Скришот 2

<img width="543" height="143" alt="Lab1 IS9 output" src="https://github.com/user-attachments/assets/d12ec592-1383-4c53-aadb-c5d38049feca" />

### Оценка времени выполнения:

Я считаю, что время выполнения этого алгоритма будет O(n), где n (как и в коде) - количество
разрядов у большего из чисел. Так как алгоритм проходит всего 1 раз по каждому из разрядов.






# Отчёт по лабораторной работе №2 (Вариант 24, Задания 1, 6, 8)

## Задание 1

### Текст задания

```
1. Используя псевдокод процедур Merge и Merge-sort из презентации к Лек-
ции 2 (страницы 6-7), напишите программу сортировки слиянием на Python и

проверьте сортировку, создав несколько рандомных массивов, подходящих
под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 2 · 104

) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109
.

• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2сек.
• Ограничение по памяти. 256 мб.
2. Для проверки можно выбрать наихудший случай, когда сортируется массив
размера 1000, 104

, 105 чисел порядка 109

, отсортированных в обратном
порядке; наилучший, когда массив уже отсортирован, и средний. Сравните,
например, с сортировкой вставкой на этих же данных.

3. Перепишите процедуру Merge так, чтобы в ней не использовались сигналь-
ные значения. Сигналом к остановке должен служить тот факт, что все

элементы массива L или R скопированы обратно в массив A, после чего в
этот массив копируются элементы, оставшиеся в непустом массиве.
или перепишите процедуру Merge (и, соответственно, Merge-sort) так, чтобы
в ней не использовались значения границ и середины - p, r и q.
```

### Код решения:

<img width="772" height="803" alt="Lab2 MS1 code" src="https://github.com/user-attachments/assets/599884d6-18bc-43fa-a3a3-75b87a936b92" />

### Пояснение:

Решение содержит сразу сортировку слиянием сразу без использования сигнальных элементов. 
В этом коде сигналом к остановке служит факт того, что все элементы массивов L и R уже
скопированы. Это реализуется за счёт того, что в коде есть 3 блока: пока в обоих массивах есть элементы, 
пока в массиве L есть элементы и пока в массиве R есть элементы. Остановка происходит, когда i == len(L) или
когда j == len(R), после чего копируются все элементы из непустого массива. 
В остальном код - это прямой перевод псевдокода сортировки слиянием в код на Python. Блок для записи и чтения
полностью такой же как в предыдущих лабах.

### Проверка работоспосоности 

В качестве доказательства работоспособности алгоритма привожу 3 блока скринов

#### Блок 1 - самый простой случай, когда массив уже отсортирован 

input.txt

<img width="513" height="302" alt="Lab2 MS1 input simple" src="https://github.com/user-attachments/assets/d658461d-da2c-460e-9a07-06e1febc6055" />

otput.txt

<img width="547" height="362" alt="Lab2 MS1 output simple" src="https://github.com/user-attachments/assets/40e7528c-0d34-4677-bd71-172f852ba53b" />




#### Блок 2 - средний случай со случайными элементами 

input.txt

<img width="550" height="359" alt="Lab2 MS1 input medium" src="https://github.com/user-attachments/assets/f5d448be-30e5-4a67-8620-e021233863d4" />


otput.txt


<img width="553" height="362" alt="Lab2 MS1 output medium" src="https://github.com/user-attachments/assets/933c6a6b-3ef0-4cca-9d96-c6861b90f86b" />



#### Блок 3 - самый сложный случай, когда массив отсортирован задом наперёд 

input.txt

<img width="548" height="366" alt="Lab2 MS1 input hard" src="https://github.com/user-attachments/assets/32535d0c-fd75-434e-ac96-556d58b95eb6" />


otput.txt

<img width="551" height="360" alt="Lab2 MS1 output hard" src="https://github.com/user-attachments/assets/a89c0a1b-9e9f-454c-a3e3-bd3f851ffebf" />




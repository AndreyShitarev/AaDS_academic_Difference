# Отчёт по лабораторной работе №2 (Вариант 24, Задания 1, 6, 8)

## Задание 1

### Текст задания

```
1. Используя псевдокод процедур Merge и Merge-sort из презентации к Лек-
ции 2 (страницы 6-7), напишите программу сортировки слиянием на Python и

проверьте сортировку, создав несколько рандомных массивов, подходящих
под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 2 · 104

) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109
.

• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2сек.
• Ограничение по памяти. 256 мб.
2. Для проверки можно выбрать наихудший случай, когда сортируется массив
размера 1000, 104

, 105 чисел порядка 109

, отсортированных в обратном
порядке; наилучший, когда массив уже отсортирован, и средний. Сравните,
например, с сортировкой вставкой на этих же данных.

3. Перепишите процедуру Merge так, чтобы в ней не использовались сигналь-
ные значения. Сигналом к остановке должен служить тот факт, что все

элементы массива L или R скопированы обратно в массив A, после чего в
этот массив копируются элементы, оставшиеся в непустом массиве.
или перепишите процедуру Merge (и, соответственно, Merge-sort) так, чтобы
в ней не использовались значения границ и середины - p, r и q.
```

### Код решения:

<img width="772" height="803" alt="Lab2 MS1 code" src="https://github.com/user-attachments/assets/599884d6-18bc-43fa-a3a3-75b87a936b92" />

### Пояснение:

Решение содержит сразу сортировку слиянием сразу без использования сигнальных элементов. 
В этом коде сигналом к остановке служит факт того, что все элементы массивов L и R уже
скопированы. Это реализуется за счёт того, что в коде есть 3 блока: пока в обоих массивах есть элементы, 
пока в массиве L есть элементы и пока в массиве R есть элементы. Остановка происходит, когда i == len(L) или
когда j == len(R), после чего копируются все элементы из непустого массива. 
В остальном код - это прямой перевод псевдокода сортировки слиянием в код на Python. Блок для записи и чтения
полностью такой же как в предыдущих лабах.

### Проверка работоспосоности:

В качестве доказательства работоспособности алгоритма привожу 3 блока скринов

#### Блок 1 - самый простой случай, когда массив уже отсортирован 

input.txt

<img width="513" height="302" alt="Lab2 MS1 input simple" src="https://github.com/user-attachments/assets/d658461d-da2c-460e-9a07-06e1febc6055" />

otput.txt

<img width="547" height="362" alt="Lab2 MS1 output simple" src="https://github.com/user-attachments/assets/40e7528c-0d34-4677-bd71-172f852ba53b" />




#### Блок 2 - средний случай со случайными элементами 

input.txt

<img width="550" height="359" alt="Lab2 MS1 input medium" src="https://github.com/user-attachments/assets/f5d448be-30e5-4a67-8620-e021233863d4" />


otput.txt


<img width="553" height="362" alt="Lab2 MS1 output medium" src="https://github.com/user-attachments/assets/933c6a6b-3ef0-4cca-9d96-c6861b90f86b" />



#### Блок 3 - самый сложный случай, когда массив отсортирован задом наперёд 

input.txt

<img width="548" height="366" alt="Lab2 MS1 input hard" src="https://github.com/user-attachments/assets/32535d0c-fd75-434e-ac96-556d58b95eb6" />


otput.txt

<img width="551" height="360" alt="Lab2 MS1 output hard" src="https://github.com/user-attachments/assets/a89c0a1b-9e9f-454c-a3e3-bd3f851ffebf" />



## Задание 6

### Текст задания:

```
Используя псевдокод процедур Find Maximum Subarray и Find Max Crossing

Subarray из презентации к Лекции 2 (страницы 25-26), напишите программу по-
иска максимального подмассива.

Примените ваш алгоритм для ответа на следующий вопрос. Допустим, у нас
есть данные по акциям какой-либо фирмы за последний месяц (год, или иной срок).

Проанализируйте этот срок и выдайте ответ, в какой из дней при покупке единицы
акции данной фирмы, и в какой из дней продажи, вы бы получили максимальную
прибыль? Выдайте дату покупки, дату продажи и максимальную прибыль.

Вы можете использовать любые данные для своего анализа. Например, я на-
брала в Google "акции" и мне поиск выдал акции Газпрома, тут - можно скачать

информацию по стоимости акций за любой период. (Перейдя по ссылке, нажмите
на вкладку "Настройки"→ "Скачать")

Соответственно, вам нужно только выбрать данные, посчитать изменение це-
ны и применить алгоритм поиска максимального подмассива.

• Формат входного файла в данном случае на ваше усмотрение.

• Формат выходного файла (output.txt). Выведите название фирмы, рас-
сматриваемый вами срок изменения акций, дату покупки и дату продажи

единицы акции, чтобы получилась максимальная выгода; и сумма этой при-
были.
```

### Код решения:

<img width="668" height="1005" alt="Lab2 MS6 Code" src="https://github.com/user-attachments/assets/d252c824-84a6-42a9-a7eb-d9d4f04f16d7" />

### Пояснение:

Суть задачи сводится к простому поиску максимального подмассива. Мы делим исходный массив пополам и у нас 
появляется 3 варианта, где может лежать максимальный подмассив: в правой части, в левой части или
начинается в левой и заканчивается в правой. И если у нас будет только функция рекурсивного поиска максимального 
подмассива, то мы не сможем корректно обрабатывать случаи, где массив лежит одновременно и справа и слева.
Поэтому мы вводим вспомогательную функцию max_crossing, которая ищет
максимальный подмассив, который точно пересечёт середину. Она работает так: идёт от середины
влево и вправо и ищет максимальные суммы (за изначальную максимальную сумму взяты очень большое
и очень маленькое числа, чтобы в массиве точно было что-то больше и что-то меньше). После того как
мы прошли и по правой и по левой части подмассива, мы возвращаем начало и конец подмассива и его сумму. 
Далее я написал основную функцию max_subarray, которая рекурсивно ищет максимальный подмассив. Она работает так.
Если в массиве всего 1 элемент - то он и является максимальным подмассивом. В ином случае мы делим массив пополам
и делаем 2 рекурсивныъ вызова max_subarray для правой и левой частей + вызываем функцию max_crossing для пересекающей середину части. 
После этого просто выбираем максимальный результат из полученных, он и будет максимальным подмассивом. Далее осталось написать
только блок для обработки входного файла и красивой записи в выходной.

### Проверка работоспособности:

Для того, чтобы доказать, что мой код работат я попросил ChatGPT написать под это задание набор данных для компании Gazprom. 
Затем обработал данные в формат для input.txt для этого задания и получил такой входной файл:

<img width="546" height="363" alt="Lab2 MS6 input" src="https://github.com/user-attachments/assets/f020f00f-02b6-4420-ab6b-e270054b0af3" />

Запустил программу и получил красивый вывод с аналитикой:

<img width="552" height="366" alt="Lab2 MS6 output" src="https://github.com/user-attachments/assets/cd0af18b-b096-4778-bd5a-9e29d36d9081" />



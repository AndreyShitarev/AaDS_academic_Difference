# Отчёт по лабораторной работе №2 (Вариант 24, Задания 1, 6, 8)

## Задание 1

### Текст задания

```
1. Используя псевдокод процедур Merge и Merge-sort из презентации к Лек-
ции 2 (страницы 6-7), напишите программу сортировки слиянием на Python и

проверьте сортировку, создав несколько рандомных массивов, подходящих
под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 2 · 104

) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109
.

• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2сек.
• Ограничение по памяти. 256 мб.
2. Для проверки можно выбрать наихудший случай, когда сортируется массив
размера 1000, 104

, 105 чисел порядка 109

, отсортированных в обратном
порядке; наилучший, когда массив уже отсортирован, и средний. Сравните,
например, с сортировкой вставкой на этих же данных.

3. Перепишите процедуру Merge так, чтобы в ней не использовались сигналь-
ные значения. Сигналом к остановке должен служить тот факт, что все

элементы массива L или R скопированы обратно в массив A, после чего в
этот массив копируются элементы, оставшиеся в непустом массиве.
или перепишите процедуру Merge (и, соответственно, Merge-sort) так, чтобы
в ней не использовались значения границ и середины - p, r и q.
```

### Код решения:

<img width="772" height="803" alt="Lab2 MS1 code" src="https://github.com/user-attachments/assets/599884d6-18bc-43fa-a3a3-75b87a936b92" />

### Пояснение:

Решение содержит сразу сортировку слиянием сразу без использования сигнальных элементов. 
В этом коде сигналом к остановке служит факт того, что все элементы массивов L и R уже
скопированы. Это реализуется за счёт того, что в коде есть 3 блока: пока в обоих массивах есть элементы, 
пока в массиве L есть элементы и пока в массиве R есть элементы. Остановка происходит, когда i == len(L) или
когда j == len(R), после чего копируются все элементы из непустого массива. 
В остальном код - это прямой перевод псевдокода сортировки слиянием в код на Python. Блок для записи и чтения
полностью такой же как в предыдущих лабах.

### Проверка работоспосоности:

В качестве доказательства работоспособности алгоритма привожу 3 блока скринов

#### Блок 1 - самый простой случай, когда массив уже отсортирован 

input.txt

<img width="513" height="302" alt="Lab2 MS1 input simple" src="https://github.com/user-attachments/assets/d658461d-da2c-460e-9a07-06e1febc6055" />

otput.txt

<img width="547" height="362" alt="Lab2 MS1 output simple" src="https://github.com/user-attachments/assets/40e7528c-0d34-4677-bd71-172f852ba53b" />




#### Блок 2 - средний случай со случайными элементами 

input.txt

<img width="550" height="359" alt="Lab2 MS1 input medium" src="https://github.com/user-attachments/assets/f5d448be-30e5-4a67-8620-e021233863d4" />


otput.txt


<img width="553" height="362" alt="Lab2 MS1 output medium" src="https://github.com/user-attachments/assets/933c6a6b-3ef0-4cca-9d96-c6861b90f86b" />



#### Блок 3 - самый сложный случай, когда массив отсортирован задом наперёд 

input.txt

<img width="548" height="366" alt="Lab2 MS1 input hard" src="https://github.com/user-attachments/assets/32535d0c-fd75-434e-ac96-556d58b95eb6" />


otput.txt

<img width="551" height="360" alt="Lab2 MS1 output hard" src="https://github.com/user-attachments/assets/a89c0a1b-9e9f-454c-a3e3-bd3f851ffebf" />



## Задание 6

### Текст задания:

```
Используя псевдокод процедур Find Maximum Subarray и Find Max Crossing

Subarray из презентации к Лекции 2 (страницы 25-26), напишите программу по-
иска максимального подмассива.

Примените ваш алгоритм для ответа на следующий вопрос. Допустим, у нас
есть данные по акциям какой-либо фирмы за последний месяц (год, или иной срок).

Проанализируйте этот срок и выдайте ответ, в какой из дней при покупке единицы
акции данной фирмы, и в какой из дней продажи, вы бы получили максимальную
прибыль? Выдайте дату покупки, дату продажи и максимальную прибыль.

Вы можете использовать любые данные для своего анализа. Например, я на-
брала в Google "акции" и мне поиск выдал акции Газпрома, тут - можно скачать

информацию по стоимости акций за любой период. (Перейдя по ссылке, нажмите
на вкладку "Настройки"→ "Скачать")

Соответственно, вам нужно только выбрать данные, посчитать изменение це-
ны и применить алгоритм поиска максимального подмассива.

• Формат входного файла в данном случае на ваше усмотрение.

• Формат выходного файла (output.txt). Выведите название фирмы, рас-
сматриваемый вами срок изменения акций, дату покупки и дату продажи

единицы акции, чтобы получилась максимальная выгода; и сумма этой при-
были.
```

### Код решения:

<img width="668" height="1005" alt="Lab2 MS6 Code" src="https://github.com/user-attachments/assets/d252c824-84a6-42a9-a7eb-d9d4f04f16d7" />

### Пояснение:

Суть задачи сводится к простому поиску максимального подмассива. Мы делим исходный массив пополам и у нас 
появляется 3 варианта, где может лежать максимальный подмассив: в правой части, в левой части или
начинается в левой и заканчивается в правой. И если у нас будет только функция рекурсивного поиска максимального 
подмассива, то мы не сможем корректно обрабатывать случаи, где массив лежит одновременно и справа и слева.
Поэтому мы вводим вспомогательную функцию max_crossing, которая ищет
максимальный подмассив, который точно пересечёт середину. Она работает так: идёт от середины
влево и вправо и ищет максимальные суммы (за изначальную максимальную сумму взяты очень большое
и очень маленькое числа, чтобы в массиве точно было что-то больше и что-то меньше). После того как
мы прошли и по правой и по левой части подмассива, мы возвращаем начало и конец подмассива и его сумму. 
Далее я написал основную функцию max_subarray, которая рекурсивно ищет максимальный подмассив. Она работает так.
Если в массиве всего 1 элемент - то он и является максимальным подмассивом. В ином случае мы делим массив пополам
и делаем 2 рекурсивныъ вызова max_subarray для правой и левой частей + вызываем функцию max_crossing для пересекающей середину части. 
После этого просто выбираем максимальный результат из полученных, он и будет максимальным подмассивом. Далее осталось написать
только блок для обработки входного файла и красивой записи в выходной.

### Проверка работоспособности:

Для того, чтобы доказать, что мой код работат я попросил ChatGPT написать под это задание набор данных для компании Gazprom. 
Затем обработал данные в формат для input.txt для этого задания и получил такой входной файл:

<img width="546" height="363" alt="Lab2 MS6 input" src="https://github.com/user-attachments/assets/f020f00f-02b6-4420-ab6b-e270054b0af3" />

Запустил программу и получил красивый вывод с аналитикой:

<img width="552" height="366" alt="Lab2 MS6 output" src="https://github.com/user-attachments/assets/cd0af18b-b096-4778-bd5a-9e29d36d9081" />




## Задание 8

### Текст задания:

```
Выдающийся немецкий математик Карл Фридрих Гаусс (1777––1855) заметил,
что хотя формула для произведения двух комплексных чисел (a + bi)(c + di) =
ac − bd + (bc + ad)i содержит четыре умножения вещественных чисел, можно
обойтись и тремя: вычислим ac, bd и (a + b)(c + d) и воспользуемся тем, что
bc + ad = (a + b)(c + d) − ac − bd.
Задача. Даны 2 многочлена порядка n − 1: an−1x

n−1 + an−2x
n−1 + ... +

a1x + a0 и bn−1x

n−1 + bn−2x

n−1 + ... + b1x + b0. Нужно получить произведение:

7

c2n−2x
2n−2 + c2n−3x

2n−3 + ... + c1x + c0, где:
c2n−2 = an−1bn−1
c2n−3 = an−1bn−2 + an−2bn−1
... ...
c2 = a2b0 + a1b1 + a0b2
c1 = a1b0 + a0b1
c0 = a0b0

Пример. Входные данные: n = 3, A = (3, 2, 5), B = (5, 1, 2)

A(x) = 3x
2 + 2x + 5
B(x) = 5x
2 + x + 2
A(x)B(x) = 15x
4 + 13x
3 + 33x
2 + 9x + 10

Ответ: C = (15, 13, 33, 9, 10).
• Формат входного файла (input.txt). В первой строке число n - порядок
многочленов A и B. Во второй строке коэффициенты многочлена A через
пробел. В третьей строке коэффициенты многочлена B через пробел.
• Формат выходного файла (output.txt). Ответ - одна строка, коэффициенты
многочлена C(x) = A(x)B(x) через пробел.

• Нужно использовать метод "Разделяй и властвуй". Подсказка: любой много-
член A(x) можно разделить на 2 части, например, A(x) = 4x

3+ 3x
2+ 2x+ 1

разделим на A1 = 4x+3 и A2 = 2x+1. И многочлен B(x) = x
3+2x
2+3x+4
разделим на 2 части: B1 = x + 2, B2 = 3x + 4. Тогда произведение
C = A(x) ∗ B(x) = (A1B1)x

n + (A1B2 + A2B1)x

n/2 + A2B2 - требу-
ется 4 произведения (проверьте правильность данной формулы). Можно

использовать формулу Гаусса и обойтись всего тремя произведениями.
```

### Код решения:

<img width="546" height="362" alt="Lab2 MS8 input" src="https://github.com/user-attachments/assets/49e14b07-a066-4978-b887-509d71a94108" />

### Пояснение:

Код использует принцип "разделяй и влавствуй" + формула Гаусса. Сначала я написал вспомогательные функции
сложения и вычитания многочленов, они будут нужны при написании основной функции Гауса. Рабоатют они максимально просто,
сильно похожи по принципу сложения двоичных чисел из прошлой лабы. Мы заполняем недостающие коэффициенты подмассивов
нулями и складываем два уже равных массива коэффициентов. В вычитании мы поэлементно вычитаем коэффициенты.
Теперь перейдём к основной функции. Функция umnozhenie(). Она работает так. Если многочлены содержат только свободные члены,
то просто умножаем коэффициенты. Далее, если многочлены не нулевой степени, то каждый из них делим пополам. Затем рекурсивно
вызываем функцию умножения и функцию вычитания. По сути мы просто превращаем формулу Гауса в код. Остаётся только собрать
результат, тоже по формуле: res = [0] * (2*n-1), то есть раскалываем коэффиценты по индексам. Ну и в конце блок кода для
чтения из input.txt и записи в output.txt.

### Проверка работоспособности:

Чтобы доказать работоспособность этого алгоритма, я дал ему на вход 2 набора коэффициентов как из примера в лабе:

<img width="546" height="362" alt="Lab2 MS8 input" src="https://github.com/user-attachments/assets/f14cb752-f765-4e71-a673-21132c9ca591" />

И на выходе получил результат, соответствующий ожидаемому результату из примера в лабе:

<img width="549" height="363" alt="Lab2 MS8 output" src="https://github.com/user-attachments/assets/a45ed5a6-6716-464d-a742-bc30ada981a2" />



